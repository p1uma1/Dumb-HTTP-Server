package org.example.httpServer.utils;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CoderResult;
import java.nio.charset.CodingErrorAction;
import java.nio.charset.StandardCharsets;

public class ByteStreamReader implements Closeable {
    private InputStream in;
    private byte[] buffer;
    private int bufferSize;


    public ByteStreamReader(InputStream in,int size) {
        this.bufferSize=size;
        this.in = in;
        buffer = new byte[this.bufferSize];
    }
    public int read() throws IOException {
        StringBuilder sb = new StringBuilder();
        CharsetDecoder decoder = StandardCharsets.UTF_8
                .newDecoder()
                .onMalformedInput(CodingErrorAction.REPORT)
                .onUnmappableCharacter(CodingErrorAction.REPORT);
        ByteBuffer byteBuf = ByteBuffer.allocate(bufferSize);
        CharBuffer charBuf = CharBuffer.allocate(bufferSize);

        int b;
        while((b=in.read())!=-1){
            byteBuf.clear();
            byteBuf.put(buffer,0,bufferSize);
            byteBuf.flip();  //from reading to writing

            while(true){
                CoderResult result = decoder.decode(byteBuf,charBuf,false);
                if(result.isOverflow()){
                    charBuf.flip();
                    sb.append(charBuf.array());
                }
            }

        }
        return -1;
    }



    public int read(String string) throws IOException {
        StringBuilder sb =new StringBuilder();
        Reader reader = new InputStreamReader(in, StandardCharsets.UTF_8);

        int ch;
        boolean startedWatching=false;
        char previousChar=Character.MIN_VALUE;
        char beforePreveiousChar = Character.MIN_VALUE;
        char beforeBeforePreveiousChar = Character.MIN_VALUE;
        boolean endOfBody = false;
        boolean endOfHeaders = false;
        int counter = 0;

        while ((ch = reader.read()) != -1 && !endOfBody) {
            char c = (char) ch;
            if(endOfHeaders){  //body
                counter++;
            }

            else if (c == '\r' || c == '\n') {  // \r or \n
                if (!startedWatching) startedWatching = true;
                else if (c == '\n' && previousChar == '\n') //\n \n
                {
                    endOfHeaders = true;
                } else if (c == '\n' && previousChar == '\r' && beforePreveiousChar == '\n' && beforeBeforePreveiousChar == '\r') {
                    endOfHeaders = true;
                }
                beforeBeforePreveiousChar=beforePreveiousChar;
                beforePreveiousChar=previousChar;
                previousChar=c;

            } else if(startedWatching){
                startedWatching = false;
            }

            sb.append(c);

        }
        string=sb.toString();
        return counter;
    }





    @Override
    public void close() throws IOException {

    }
}
